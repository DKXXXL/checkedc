\section{Formalism}\label{sec:formal}

\begin{figure}
  \small \centering
  \[ \hspace*{-1.5em}
\setlength{\arraycolsep}{4pt}
\begin{array}{l}
\begin{array}{ll}
       \text{Variables:}~ x
& \quad\text{Integers:}~n::=\mathbb{Z} 
\end{array}
\\[0.5em]
\begin{array}{llcllcl}
\text{Context Mode:} & m & ::= & \cmode \mid \umode \\[0.2em]
\text{Memory Mode:} & \kappa & ::= & m \mid \tmodered \\[0.2em]
\text{Bound:} & b & ::= & n \mid x \plus n \\[0.2em]
              & \bvar & ::= & (b,b) \\[0.2em]
  
     \text{Word Type:}& \tau &::=& \tint\mid \tptr{\omega}{\kappa}
\\[0.2em]
\text{Type:}&\omega &::=& \tau \mid \tarrayb{\bvar}{\tau} \mid \textcolor{red}{\tfun{\overline{x}}{\overline{\tau}}{\tau}}
\\[0.2em]
\text{Expression:}& e & ::= & 
\evalue{n}{\tau} \mid x \mid \ebinop{e}{e}\mid \ecast{\tau}{e} \mid \estar{e}\mid\eassign{e}{e} 
  \\[0.2em]
&&\mid& \textcolor{red}{\emalloc{\kappa}{\omega}} \mid \textcolor{red}{\toa{m}{\overline{x}}{e}} \\[0.2em]
&&\mid&\eif{e}{e}{e} \mid  \elet{x}{e}{e} \mid \textcolor{red}{\ecall{e}{\overline{e}}}
\end{array}
    \end{array}
  \]
  \caption{\lang Syntax}
  \label{fig:checkc-syn}
\end{figure}

\begin{figure}
{
\begin{center}
\includegraphics[width=0.35\textwidth]{memory.png}
\end{center}
}
\caption{
    \systemname separate heap layouts
}
  \label{fig:checkc-memory}
\end{figure}

\begin{figure}
{
  \small \centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\diagbox{\text{Context}}{\text{Memory}}
& $\texttt{malloc}$ & $\estar{e}$ & $\eassign{e}{e}$ & $\ecall{e}{\overline{e}}$\\[0.1em]
\hline
\cmode&$\cmodenor$,$\tmodenor$ & $\cmodenor$,$\tmodenor$ & $\cmodenor$,$\tmodenor$ & $\cmodefun$,$\tmodefun$\\[0.1em]
\hline
\umode&$\tmodenor$,$\umode$ & $\tmodenor$,$\umode$ & $\tmodenor$,$\umode$ & $\tmodefun$,$\umode$\\[0.1em]
\hline
    \end{tabular}
}
  \caption{Permitted Memory Modes in Context Regions}
  \label{fig:checkc-mode}
\end{figure}

\begin{figure}[t]
{\small
  \begin{mathpar}

  \inferrule[]
  {}
  {m \vdash \tint}
\qquad
  \inferrule[]
  {\kappa \wedge m\vdash \tau \\ \kappa \le m}
  {m \vdash \tptr{\tarrayb{\bvar}{\tau}}{\kappa}}
\qquad
  \inferrule[]
  {\kappa \wedge m \vdash \tau\\ \kappa \le m}
  {m \vdash \tptr{\tau}{\kappa}}

  \inferrule[]
  {\forall \tau'\in \overline{\tau}\cup\{\tau\}\,.\,\kappa \wedge m \vdash \tau'\\ \kappa \le m \\ \fv(\overline{\tau})\cup\fv(\tau)\subseteq \overline{x}}
  {m \vdash \tptr{(\tfun{\overline{x}}{\overline{\tau}}{\tau}}{\kappa})}
  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l} 
m \le m \qquad \tmode \le \kappa
\\[0.2em]
\tmode \wedge \cmode = \umode \qquad \kappa \wedge \umode = \umode
\qquad \cmode \wedge m = m 
\qquad  m_1 \wedge m_2 = m_2 \wedge m_1

\end{array}
\]
}
 \caption{Well-formedness for Types}
\label{fig:wftypes}
\end{figure}

This section describes \lang, the formal core model for both \systemname and \systemnamea.
We present its syntax, semantics, type system,
as well as \langâ€™s meta-theories, including the non-exposure, type soundness, and non-crashing theorems,
which are verified without the assumptions of the underlining sandbox structure.
\lang utilizes dynamic checks that are inserted in the compilation time to ensure memory safety, i.e.,
the \lang semantics (\Cref{sec:semantics}) describes the dynamic checks to perform in transitions,
while its type system (\Cref{sec:typechecking}) indicates the places needing for inserting such checks.

\subsection{Syntax}\label{sec:syntax}
\Cref{fig:checkc-syn} shows the syntax of~\lang, with marked red items being new added features different from the \checkedc model \cite{li22checkedc}.

\myparagraph{Types}
%
\systemname and \checkedc are similar in terms of type syntax, except for function types.
We classify types as word-size value, multi-word
value, or newly introduced function types (explained shortly below). A word-size value can be either an integer or pointer.
Every pointer type ($\tptr{\omega}{\kappa}$) includes a
memory mode (explained shortly below), and a type ($\omega$) denoting the valid value type it is pointed to.
A multi-word value type ($ \tarrayb{\bvar}{\tau}$) that ranges over 
arrays is constructed by the type of elements in the
array ($\tau$), and a bound ($\bvar$) comprised of an upper and
lower bound on the size of the array $(b_l,b_h)$.
Bounds $b$ are
limited to integer literals $n$ and expressions $x + n$.
An example representation of an array in~\lang is shown below:
% 
\[\hspace*{-0.5em}
\begin{array}{l}
\begin{array}{rcl}
$\code{t_array_ptr<}$\tau$\code{> : count(}$n$\code{)}$
&\Leftrightarrow& \tarrayptr{0}{n}{\tau}{\tmode}
\end{array}
\end{array}
\]

For simplicity, we write
$\tptr{\tarrayb{b}{\tau}}{\cmode}$ to mean $\tptr{\tarray{0}{b}{\tau}}{\cmode}$,
so the above examples could be rewritten as $\tptr{\tarrayb{n}{\tau}}{\tmode}$.
There are other syntactic categories for modeling null-terminated array and \code{struct} types in \Cref{app:main}.

\myparagraph{Modes and Type Well-formedness}
%
In \checkedc, modes can act as a context division to partition code into checked (\cmode) and unchecked (\umode) regions, and a pointer separation to divide pointers into checked (\cmode) and unchecked (\umode) pointers.
In \systemname, we keep the context division, while upgrade mode's pointer separation aspect to a memory partition mechanism that separates heap into three disjoint areas: checked (\cmode), tainted (\tmode), or unchecked (\umode) heap regions.

More specifically, we partition each of the above heap regions to a subrange (subscripted by $\texttt{f}$) storing static function code data, and a subrange (subscripted by $\texttt{n}$) storing normal heap data,
so function pointers and heap pointers point to different subranges conceptually.
Different operations in different context regions are allowed to access pointers with different modes, shown in \Cref{fig:checkc-mode}.
For example, \texttt{malloc} operations in \cmode region produce pointers accessing $\cmodenor$ or $\tmodenor$ memory subranges, while a \texttt{malloc} in $\umode$ region produces a pointer accessing $\tmodenor$ and $\umode$ subranges.
Function calls ($\ecall{e}{\overline{e}}$) in \cmode region are allowed to access pointers in $\cmodefun$ or $\tmodefun$ subranges,
while calls in \umode region are permitted to access pointers in the $\umode$ heap region.

\systemname nested pointers also has well-formedness type restrictions in~\Cref{fig:wftypes},
to prevent unsafe pointers, which might leak \cmode mode pointer address to \umode regions, from being constructed.
Consider the pointer type ~\code{t_array_ptr<ptr<int>>}, which describes a tainted array of checked pointers.
This is not well-formed in~\lang because it potentially exposes the checked pointer addresses in a $\umode$ region (a violation of the non-exposure property in \Cref{sec:theorem}), when the tainted ($\tmode$) array is used. Nevertheless, we can have a checked array whose elements are tainted pointers\mzs{,}\mzr{:}~\eg~\code{array_ptr<t_ptr<int>>} is a valid type.

Function types represent dependent functions,~\ie $\tfun{\overline{x}}{\overline{\tau}}{\tau}$,
where $\overline{x}$ represents a list of \tint{} type variables that bind type variables appearing in $\overline{\tau}$ and $\tau$.
An example of a function pointer type is shown below:
{\small
\[\hspace*{-0.5em}
\begin{array}{l}
$\code{t_ptr<(int)(t_array_ptr<}$\tau_1$\code{> : count(}$n$\code{),}$\\
\qquad\qquad$\code{t_array_ptr<}$\tau_2$\code{>: count(}$n$\code{), int}$\;n$\code{)>}$
\\[0.2em]
\Leftrightarrow\; $\tptr{(\tfun{n}{\tint \times \tarrayptr{0}{n}{\tau_2}{\tmode} \times \tarrayptr{0}{n}{\tau_1}{\tmode}}{\tint})}{\tmode}$
\end{array}
\]
}
The function type also has well-formedness definition (\Cref{fig:wftypes}), which disallows nesting checked pointers inside tainted pointers. Furthermore, the well-formedness also ensures that all variables in $\overline{\tau}$ and $\tau$ are bounded by $\overline{x}$.

\myparagraph{Expressions}
\lang expressions include common expressions such as addition ($\ebinop{e_1}{e_2}$), 
pointer dereference ($\estar{e}$) and assignment ($\eassign{e_1}{e_2}$),
along with expressions that require special handling, such as,
 static casts ($\ecast{\tau}{e}$),
memory allocations ($\emalloc{\kappa}{\omega}$), 
function calls ($\ecall{e}{\overline{e}}$).
We denote integer literals $n$ with a type $\tau$ (\ie $\tint$ or $\tptr{\omega}{\kappa}$), enabling the use of fixed addresses as pointers.
For example, $\evalue{0}{\tptr{\omega}{\kappa}}$ (for any $\kappa$ and $\omega$) represents a $\enull$ pointer.

Compared with \checkedc, \lang's \texttt{malloc} operation includes a mode $\kappa$ to model the allocations of pointers with different modes; $e$ in a function call $\ecall{e}{\overline{e}}$ represents a function pointer whose pointer mode indicates the memory range the function text locates, as well as the context-switch of context regions, explained shortly in \Cref{sec:semantics}.

\lang{} aims to be simple enough to work with but powerful enough to
encode realistic \systemname idioms. For example,
loops can be encoded as recursive function calls. 
More operations, such as \code{struct}s are given in \Cref{app:main}.

\subsection{Semantics}\label{sec:semantics}

\begin{figure}
{\small
$\hspace*{-1.2em}
    \begin{array}{l}
    \begin{array}{lll}
\mu & ::= & \evalue{n}{\tau} \mid \bot\\[0.1em]
e & ::= & \ldots \mid \ret{x}{\mu}{e}\\[0.1em]
r & ::= & e \mid \enull \mid \ebounds\\[0.1em]
E &::=& \Box \mid \ebinop{E}{e} \mid \ebinop{\evalue{n}{\tau}}{E}\mid \ecast{\tau}{E} \mid\estar{E}\mid\eassign{E}{e}
\mid\eassign{\evalue{n}{\tau}}{E}\\[0.1em]
&\mid& \eif{E}{e}{e}\mid \elet{x}{E}{e}\mid\ret{x}{\mu}{E}\\[0.1em]
&\mid& \textcolor{red}{\ecall{E}{\overline{e}}} \mid \textcolor{red}{\ecall{(\evalue{n}{\tau})}{\overline{E}}}
\mid \textcolor{red}{\toa{m}{\overline{x}}{e}}\\[0.1em]
\overline{E} &::=& E \mid  \evalue{n}{\tau},\overline{E} \mid \overline{E}, e
\end{array}
\\ \\
    \end{array} 
$
  \begin{mathpar}
    \inferrule[S-Frame]{ m=\mode(E) \\
      e=E[e'] \\
      (\varphi,\heap,e') \longrightarrow (\varphi',\heap',e'')}
    {(\varphi,\heap,e)\longrightarrow_{m} (\varphi',\heap',E[e''])}

\textcolor{red}{
    \inferrule[S-Recov]{ \umode=\mode(E) \\ \tau=\type(e)}
    {(\varphi,\heap,E[e])\longrightarrow_{\umode} (\varphi,\heap,E[\evalue{0}{\tau}])}
}

  \end{mathpar}
}
  \caption{\lang Semantics: Evaluation}
  \label{fig:c-context}
\end{figure}


The operational semantics for \lang is defined as a small-step
transition relation with the judgment $ (\varphi,\heap,e)
\longrightarrow_m (\varphi',\heap',r)$. Here, $\varphi$ is a
\emph{stack} mapping from variables to values $\evalue{n}{\tau}$ and
$\heap$ is a \emph{heap} that is partitioned into three parts ($\cmode$, $\tmode$, and $\umode$ heap regions), each of which
maps addresses (integer literals) to values $\evalue{n}{\tau}$; for all we ensure
$\fv(\tau)=\emptyset$.

While heap bindings can change, stack bindings are immutable---once
variable $x$ is bound to $\evalue{n}{\tau}$ in $\varphi$, that binding will not
be updated. 
We wrote $\heap(\kappa)$ to access the $\kappa$ heap region in $\heap$ and
$\heap(\kappa,n)$ to retrieve the $n$-location heap value in the $\kappa$ heap.
As mentioned, value $\evalue{0}{\tau}$
represents a $\enull$ pointer when $\tau$ is a pointer type.
Correspondingly, $\heap(m,0)$ should always be undefined.
For $\kappa=\cmode \vee \kappa = \tmode$, there is a bound value $\eta_{\kappa}$,
such that range $(0,\eta_{\kappa})$ in $\heap(\kappa)$ is reserved for function code storage, 
where we define function $\Xi(\kappa,n)$ to access the function code appearing in the $n$-th location of $\kappa$ heap region.

The relation steps to a \emph{result} $r$,
which is either an expression or a $\enull$ or $\ebounds$ failure,
representing a null-pointer dereference or out-of-bounds access,
respectively. Such failures are a \emph{good} outcome; stuck states
(non-value expressions that cannot transition to a result $r$)
characterize undefined behavior.
%
The context mode $m$ indicates whether the
stepped redex within $e$ was in a $\cmode$ or $\umode$ code region.

The rules for the main operational semantics
judgment---\emph{evaluation}---are given at the bottom of
Fig.~\ref{fig:c-context}.
The first rule takes an expression $e$, decomposes
it into an \emph{evaluation context} $E$ and a sub-expression $e'$
(such that replacing the hole $\Box$ in $E$ with $e'$ would yield
$e$), and then evaluates $e'$ according to the \emph{computation}
  relation $(\varphi,\heap,e') \longrightarrow (\varphi,\heap,e'')$,
whose rules are given in Fig.~\ref{fig:semantics}, discussed
shortly. 
Evaluation contexts $E$ define a
standard left-to-right evaluation order.
For example, context $\ecall{(\evalue{n}{\tau})}{\overline{E}}$ means that after the function pointer expression $e$ in $\ecall{e}{\overline{e'}}$ is evaluated to a function pointer $\evalue{n}{\tau}$, we now evaluate each argument expression, appearing in $\overline{e'}$, in sequence, such redex is marked as $\overline{E}$.

Compared with the \checkedc formalism, other than the additional contexts in \Cref{fig:c-context},
we add a new marked red rule \rulelab{S-Recov},
referring to that every $\umode$ region transition step might crash, because it represents the unsafe code,
and we have a mechanism to recover the crash as $\evalue{0}{\tau}$ \footnote{Function $\type$ represents the call of the type judgment in \Cref{sec:typechecking} to provide the type of the expression.}.
The $\mode$ function
determines the mode when evaluating $e'$ based on the context $E$:
if the $\Box$ occurs within $\toa{m}{\overline{x}}{E'}$ inside $E$ and $E'$ does not contain another $\totext$ expression, 
then the mode is $m$.
Expression $\ret{x}{\mu}{e}$ does not appear in source program syntax in \Cref{fig:checkc-syn}, are introduced in evaluating programs,
which is used for remembering $x$ was previously bound to
$\varphi(x)$ in a $\elettext$ binding, explained shortly below.

%The second rule in \Cref{fig:c-context} is newly introduced in \lang, to help the proof of the non-crashing theorem.
%In any given time, executing a unchecked region might non-deterministically cause the program to crash. We assume that there is a recovery mechanism for recover every such crashing, only in unchecked regions, to an initial state $\evalue{0}{\tau}$;
%thus, non-crashing shows that every unchecked region crashing does not affect the program evaluation in the checked regions.

\begin{DIFnomarkup}
\begin{figure*}[t]
{\footnotesize
  \begin{mathpar}
    \inferrule[S-DefArr]{\kappa \neq \tmode\\ n\ge\eta_{\tmode} \\\heap(\kappa,n)=\evalue{n_a}{\tptr{\tau_a}{\kappa}} \\ 0 \in [n_l,n_h)}
    {(\varphi,\heap,\estar{\evalue{n}{\tntarrayptr{n_l}{n_h}{\tau}{\kappa}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}

        \inferrule[S-Def]{\kappa \neq \tmode\\n\ge\eta_{\tmode} \\\heap(n)=\evalue{n_a}{\tptr{\tau_a}{\kappa}} }
    {(\varphi,\heap,\estar{\evalue{n}{\tptr{\tau}{\kappa}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}

    \inferrule[S-DefArrT]{n\ge\eta_{\tmode}\\\heap(\kappa,n)=\evalue{n_a}{\tptr{\tau_a}{\tmode}} \\ 0 \in [n_l,n_h)\\\heap;\emptyset \vdash \evalue{n_a}{\tau}}
    {(\varphi,\heap,\estar{\evalue{n}{\tntarrayptr{n_l}{n_h}{\tau}{\kappa}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}

        \inferrule[S-DefT]{n\ge\eta_{\tmode}\\\heap(n)=\evalue{n_a}{\tptr{\tau_a}{\tmode}}\\\heap;\emptyset \vdash \evalue{n_a}{\tau}}
    {(\varphi,\heap,\estar{\evalue{n}{\tptr{\tau}{\kappa}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}

    \inferrule[S-DefArrBound]{0 \not\in [n_l,n_h)}
     { (\varphi,\heap,\estar{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau}{\kappa}}}) \longrightarrow (\varphi,\heap,\ebounds)}

    \inferrule[S-DefNullF]{n<\eta_{\tmode}}{(\varphi,\heap,\estar{\evalue{n}{\tptr{\omega}{\kappa}}}) \longrightarrow (\varphi,\heap,\enull)}

    \inferrule[S-DefNull]{\heap(\kappa',n)=\evalue{n_a}{\tptr{\tau_a}{\kappa}}\\\kappa\neq\kappa'}{(\varphi,\heap,\estar{\evalue{n}{\tptr{\omega}{\kappa}}}) \longrightarrow (\varphi,\heap,\enull)}

    \inferrule[S-Cast]
              {}
              {(\varphi,\heap,\ecast{\tau}{\evalue{n}{\tau'}}) \longrightarrow (\varphi,\heap,\evalue{n}{\varphi(\tau)})}

  \inferrule[S-Malloc]{\varphi(\omega)=\omega_a \\ alloc(\heap,\kappa,\omega_a)=(n,\heap')}
   { (\varphi,\heap,\emalloc{\kappa}{\omega}) \longrightarrow (\varphi,\heap',\evalue{n}{\tptr{\omega_a}{\kappa}})}

    \inferrule[S-Switch]
              {}
              {(\varphi,\heap,\toa{m}{\overline{x}}{\evalue{n}{\tau}}) \longrightarrow (\varphi,\heap,\evalue{n}{\tau})}

        \inferrule[S-Let]{}{(\varphi,\heap,\elet{x}{\evalue{n}{\tau}}{e}) \longrightarrow (\varphi[x\mapsto \evalue{n}{\tau}],\heap,\ret{x}{\varphi(x)}{e})}

    \inferrule[S-Fun]{ \kappa\neq \umode\\n\in(0,\eta_{\kappa})\\\Xi(\kappa,n) = \tau\;(\evalue{\overline{x}}{\overline{\tau}})\;e}
        {(\varphi,\heap,\ecall{(\evalue{n}{\tptr{\tau}{\kappa})}}{{\evalue{\overline{n_a}}{\overline{\tau_a}}}}) \longrightarrow
   (\varphi,\heap, \mathtt{let}\;\overline{x}={\evalue{\overline{n}}{(\overline{\tau}[\overline{n} / \overline{x}])}}\;\mathtt{in}\;\ecast{\tau[\overline{n} / \overline{x}]}{e})}

    \inferrule[S-Ret]{}{(\varphi,\heap,\ret{x}{\mu}{\evalue{n}{\tau}}) \longrightarrow (\varphi[x\mapsto \mu],\heap,\evalue{n}{\tau})}

    \inferrule[S-FunU]{ n\in(0,|\heap(\umode)|)\\ \Xi(\umode,n) = \tau\;(\evalue{\overline{x}}{\overline{\tau}})\;e}
        {(\varphi,\heap,\ecall{(\evalue{n}{\tptr{\tau}{\umode})}}{{\evalue{\overline{n_a}}{\overline{\tau_a}}}}) \longrightarrow
   (\varphi,\heap, \mathtt{let}\;\overline{x}={\evalue{\overline{n}}{(\overline{\tau}[\overline{n} / \overline{x}])}}\;\mathtt{in}\;\ecast{\tau[\overline{n} / \overline{x}]}{e})}
\end{mathpar}
}
% {\footnotesize
% \begin{center}
% $
% \begin{array}{l}
% \tau[\overline{n} / \overline{x}]\texttt{(with types }\evalue{\overline{x}}{\overline{\tau}}\texttt{)}\triangleq \forall n_i\in\overline{n}\;x_i\in\overline{x}\;\tau_i\in\overline{\tau}\;.\;\tau_i = \tint \Rightarrow \tau[n_i / x_i]\\[0.2em]
% \mathtt{let}\;\overline{x}=\overline{e}\;\mathtt{in}...\triangleq \mathtt{let}\;x_0=e_0\;\mathtt{in}\;\mathtt{let}\;x_1=e_1\;\mathtt{in}...
% \end{array}
% $
% \end{center}
% }
\caption{\lang Semantics: Computation (Selected Rules)}
\label{fig:semantics}
\end{figure*}
\end{DIFnomarkup}

\ignore{
\begin{figure}[t]
{\small
{\captionsetup[lstlisting]{margin = 8 mm}
  \begin{lstlisting}[xleftmargin=8 mm]
nt_array_ptr<char> safe_strcat
   (nt_array_ptr<char> dst : count(n),
    nt_array_ptr<char> src : count(0), int n) {
  int x = strlen(dst);
  int y = strlen(src);
  nt_array_ptr<char> c : count(n) =
    dyn_bounds_cast
           <nt_array_ptr<char>>(dst,count(n));
    // sets c == dst with bound n (not x)
  if (x+y < n) {
    for (int i = 0; i < y; ++i)
      *(c+x+i) = *(src+i);
    *(c+x+y) = '\0';
    return dst;
  }
  return null;
}
  \end{lstlisting}
}
}
\caption{Implementation of safe \code{strcat}}
\label{fig:strcat-ex}
\end{figure}
}

\Cref{fig:semantics} shows selected rules for showing the key guarantees that \systemname and \systemnamea provide
; we explain them with the help of the example in
\Cref{sec:overview}.
\ignore{
  which defines a 
  safe version of \code{strcat} (using actual Checked C syntax).  The
  function takes a target 
  pointer \code{dst} of capacity \code{n}, where the first null
  character (determined by \code{strlen}) is at index \code{x} where
  $0 \leq $\code{x}$ \leq n$. It concatenates the \code{src} buffer to
  the end of \code{dst} as long as \code{dst} has sufficient space.
}
% Below, we introduce low-level transition semantics for some case operations. The design of the low-level individual operation semantics is carefully engineered to perform match our compiler's behavior, such as correctly characterizing the bound widening behaviors for NT-array pointers, even though it is written in terms of fat-pointer formalization.

\myparagraph{Pointer accesses, Casts, and Mallocs.}
%
We describe rules (\rulelab{S-DefArr}, \rulelab{S-Def}, \rulelab{S-DefArrBound}, \rulelab{S-DefNull}, and \rulelab{S-Cast}) for dereference and cast operations to illustrate how the dynamic checks are performed in \lang.
For every heap region $\heap(\kappa)$, every dereference and assignment operation (e.g., rule \rulelab{S-Def}) ensures that the pointer address is within the low and high bound range ($[\eta_{\kappa},|\heap(\kappa)|)$) of the heap region,
where the low bound refers to the bound $\eta_{\kappa}$ splitting the function code and heap data subranges
and the high bound is the cardinality of the heap ($|\heap(\kappa)|$).
If the check is not satisfied, the semantics produces a $\enull$ state in \rulelab{S-DefNull}.
When $\enull$ is returned by the
computation relation, the evaluation relation halts the entire
evaluation with $\enull$ (using a rule not shown in Fig.~\ref{fig:c-context}); it
does likewise when $\ebounds$ is returned (see below).

\rulelab{S-DefArr} dereferences an element in an array as long as $0$ (the point of
dereference) is within the bounds designated by the pointer's annotation
and strictly less than the upper bound ($0 \in [n_l,n_h)$),
while the location address $n$ should be within the bounds of the specific heap region ($n\in[\eta_{\kappa},|\heap(\kappa)|)$).
The former check is a $\ebounds$ check that verifies the element dereference is within the array bound,
while the latter is a $\enull$ check that ensures that the pointer exists in the correct heap region.
The dereference semantics and type rules are general enough to be used in both $\cmode$ and $\umode$ code regions.
As we mentioned in \Cref{sec:background}, $\umode$ code regions contain mostly C code that does not have array annotations.
In this case, a $\umode$ mode array pointer is cast and viewed as a normal C pointer, where we apply rule \rulelab{S-Def} to deal with its dereference.

Rules \rulelab{S-DefArrT} and \rulelab{S-DefT} define the dereference operations for $\tmode$ mode pointers.
Here, we perform an additional type verification $\heap;\emptyset \vdash \evalue{n_a}{\tau}$ making sure that the memory location context $n_a$ has the declared type $\tau$ appearing in the operation $\estar{\evalue{n}{\tptr{\tau}{\kappa}}}$.
Such check not only verifies if $n_a$ has type $\tau$, but also if $n_a$ is a nested pointer,
the check further verifies if all addresses within $n_a$'s legal scopes are well-typed.
In \Cref{lst:final}, function \code{read_msg} casts a $\umode$ mode pointer and assigns it to a tainted array pointer and returns to the checked function \code{process_req2}; such behavior is legal in a $\umode$ code region. 
\code{process_req2} catches the bug in line 10 through the type verification above, because pointer $x$ cannot have type $\tptr{\tarrayptr{0}{5}{\tint}{\tmode}}{\tmode}$ since it is illegal to cast type $\tptr{\tptr{\umode}{\tint}}{\tmode}$ to it.

Static casts of a literal $n\!:\!\tau'$ to a type $\tau$ are handled
by \rulelab{S-Cast}. In a type-correct program, such casts are
confirmed safe by the type system. To evaluate a cast, the rule
updates the type annotation on $n$. Before doing so, it must
``evaluate'' any variables that occur in $\tau$ according to their
bindings in $\varphi$. As an instance, if $\tau$ was
$\tarrayptr{0}{x+2}{\tint}{\cmode}$, then $\varphi(\tau)$ would
produce $\tarrayptr{0}{4}{\tint}{\cmode}$ if $\varphi(x) = 2$.
Rule \rulelab{S-Malloc} creates a new memory pointer $\tptr{\omega_a}{\kappa}$
in heap region $\heap(\kappa)$ through function $alloc$, which returns a neq heap $\heap'$ that creates a new memory space in $\heap(\kappa)$ and increments $\heap(\kappa)$'s cardinality, as $|\heap'(\kappa)|=|\heap(\kappa)|+$\code{sizeof}$(\omega_a)$;
$\varphi(\omega)$ evaluates potential bound variables in $\omega$ and returns a new type $\omega_a$ with no variables.

\myparagraph{Binding, Function Calls, and Context Switching}
We handle variable scopes using the special $\erettext$
operation. \textsc{S-Let} evaluates to a configuration whose stack
is $\varphi$ extended with a binding for $x$, and whose expression is
$\ret{x}{\varphi(x)}{e})$ which remembers $x$ was previously bound to
$\varphi(x)$; if it had no previous binding, $\varphi(x) =
\bot$. Evaluation proceeds on $e$ until it becomes a literal
$n\!:\!\tau$, in which case \textsc{S-Ret} restores the saved
binding (or $\bot$) in the new stack, and evaluates to
$n\!:\!\tau$. 

Function calls are handled by rules \rulelab{S-FunU} and \rulelab{S-Fun},
for $\umode$ and non-$\umode$ mode functions \footnote{A $\kappa$ mode function means the function pointer is labeled with mode $\kappa$ and its code is stored in $\kappa$ heap region.}, respectively.
When calling a function pointer $\evalue{n}{\tptr{\tau}{\kappa}}$,
we extra the $n$-th location code data from $\Xi(\kappa)$, referring to the function code fields in the $\kappa$ heap region and makes a memory address to $\tau\;(\evalue{\overline{x}}{\overline{\tau}})\;e$, where
$\tau$ is the return type, $(\evalue{\overline{x}}{\overline{\tau}})$
is the parameter list of variables and their types, and $e$ is the
function body.
We place a bound check in rule \rulelab{S-Fun} to 
ensure that $\cmode$ and $\tmode$ mode function calls only access addresses in the range $(0,\eta_{\kappa})$,
the code data field ranges for $\cmode$ and $\tmode$, respectively;
while $\umode$ function calls (\rulelab{S-FunU}) are allowed to access all $\umode$ heap region.
Similar to \checkedc, \lang function calls are dependent, i.e.,
array bounds in types may refer to in-scope variables; e.g., 
\code{process_req1}'s bound \code{count(m_1)} refers to parameter \code{m_1} in \Cref{lst:final}
The call is expanded into a \texttt{let} which binds
parameter variables $\overline{x}$ to the actual arguments
$\overline{n}$, but annotated with the parameter types
$\overline{\tau}$ (this will be safe for type-correct programs). The
function body $e$ is wrapped in a static cast
$(\tau[\overline{n} / \overline{x}])$ which is the function's return
type but with any parameter variables $\overline{x}$ appearing in that
type substituted with the call's actual arguments $\overline{n}$. 
\ignore{
To
see why this is needed, suppose that \code{safe_strcat} in
Fig.~\ref{fig:strcat-ex} is defined to return a
\code{nt_array_ptr<int>:count(n)} typed term, and assume that we
perform a \code{safe_strcat} function call as
\code{x=safe_strcat(a,b,10)}. After the evaluation of \code{safe_strcat}, the
function returns a value with type \code{nt_array_ptr<int>:count(10)}
because we substitute bound variable \code{n} in the 
defined return type with \code{10} from the function call's
argument list.
}
Note that the \textsc{S-Fun} rule replaces the
  annotations $\overline{\tau_a}$ with
  $\overline{\tau}$ (after instantiation) from the function's
  signature. Using $\overline{\tau_a}$ when executing the body of
the function has no impact on the soundness of \lang, but will violate
Theorem~\ref{simulation-thm}, which we introduce in Sec.~\ref{sec:compilation}.
Rule \rulelab{S-Swtich} defines the context mode switch block's semantics, which gets rid of the $\texttt{to}$ block once its context is a value.

\subsection{Typing}
\label{sec:typechecking}

\begin{DIFnomarkup}
\begin{figure*}[t]
{\small
  \begin{mathpar}
    \inferrule[T-DefArr]
              {\kappa\le m \\ \Gamma;\Theta \vdash_{m} e : \tptr{\tarrayb{\bvar}{\tau}}{\kappa}}
              {\Gamma;\Theta \vdash_m \estar{e} : \tau}

    \inferrule[T-Def]
              {\kappa \leq m \\\Gamma \vdash_m e : \tptr{\tau}{\kappa}}
              {\Gamma \vdash_m \estar{e} : \tau}

     \inferrule[T-Cast]
               {\Gamma \vdash_{\cmode} e : \tau' \\
                 \tau' \sqsubseteq \tptr{\tau}{\kappa}}
               {\Gamma \vdash_{\cmode} \ecast{\tptr{\tau}{\kappa}}{e} : \tptr{\tau}{\kappa}}

    \inferrule[T-CastU]
              {\kappa \le \umode \\
                \Gamma;\Theta \vdash_{\umode} e : \tau'}
              {\Gamma;\Theta \vdash_{\umode} \ecast{\tptr{\tau}{\kappa}}{e} : \tptr{\tau}{\kappa}}
                
    \inferrule[T-Malloc]
              {\kappa\le m}
              {\Gamma \vdash_m \emalloc{\kappa}{\omega} : \tptr{\omega}{\kappa}}

   \inferrule[T-Let]
    { x\not\in \fv(\tau') \\
        \Gamma \vdash_m e_1 : \tau \\\\
          \Gamma[x\mapsto \tau] \vdash_m e_2 : \tau'
             }
    {\Gamma \vdash_m \elet{x}{e_1}{e_2} : \tau'}

   \inferrule[T-LetInt]
    {\Gamma \vdash_m e_1 : \tint \\\\
           \Gamma[x\mapsto \tint] \vdash_m e_2 : \tau'\\\\
        x\in \fv(\tau') \Rightarrow e_1 \in \text{Bound} 
             }
    {\Gamma \vdash_m \elet{x}{e_1}{e_2} : \tau'[e_1 / x]}

\inferrule[T-Ret]
    {\Gamma(x)\neq \bot \\
          \Gamma;\Theta \vdash_m e : \tau}
    {\Gamma;\Theta \vdash_m \eret{x}{\mu}{e} : \tau}

    \inferrule[T-Switch]
              {\forall x\in\{\overline{x}\}.\,\neg\cmode(\Gamma(x))\\\neg\cmode(\tau)
                     \\\\\fv(e)\subseteq\overline{x}\\\Gamma \vdash_{m'} e : \tau}
              {\Gamma \vdash_m \toa{m'}{\overline{x}}{e} : \tau}

\inferrule[T-Fun]
    {\Gamma \vdash_m e : \tptr{\tfun{\overline{x}}{\overline{\tau}}{\tau}}{\kappa} \\
        \Gamma \vdash_m \overline{e} : \overline{\tau'} \\
         \overline{e'}=\{e'|(e',\tint)\in (\overline{e} : \overline{\tau'})\}\\\\
         \forall e'\;.\;e' \in \overline{e'} \Rightarrow e'\in \text{Bound}\\
             \overline{\tau'} \sqsubseteq
               \overline{\tau}[\overline{e'} / \overline{x}]}
    {\Gamma \vdash_m e(\overline{e}) : \tau[\overline{e'} / \overline{x}]}
  \end{mathpar}
}
% {\footnotesize
% \begin{center}
% $
% \begin{array}{l}
% \fm(e)\triangleq(\exists x\; n\; \tau. e=x+\evalue{n}{\tau}) \vee (\exists n\;\tau. e = \evalue{n}{\tau})
% \\[0.2em]
% \tau[\overline{e} / \overline{x}]\texttt{(with types }\evalue{\overline{x}}{\overline{\tau}}\texttt{)}\triangleq \forall e_i\in\overline{e}\;x_i\in\overline{x}\;\tau_i\in\overline{\tau}\;.\;\tau_i = \tint \wedge (x_i \in \fv(\tau) \Rightarrow \fm(e_i)) \Rightarrow \tau[e_i / x_i]
% \end{array}
% $
% \end{center}
% }
{\footnotesize
\begin{center}
$
\cmode(\tint)=\texttt{false}
\qquad
\cmode(\tptr{\omega}{\cmode})=\texttt{true}
\qquad
\cmode(\tptr{\omega}{\kappa})=\texttt{false}\;\;{[\emph{owise}]}
$
\end{center}
}
\caption{Selected type rules}
\label{fig:type-system-1}
\end{figure*}
\end{DIFnomarkup}

The \lang type system is a flow-sensitive, gradual type one that generates additional dynamic checks that are inserted in the typing checking stage and executed in the semantic evaluation stage.
Our type checker restricts the usage of tainted and checked pointer types to ensure that tainted pointers do not affect checked types, along with enforcing~\checkedc typing rules~\cite{li22checkedc}.

As partly shown in \Cref{fig:type-system-1} (labeled as \rulelab{T-}$X$),
each typing judgment has the form $\Gamma;\Theta\vdash_m e : \tau$,
which states that in a type environment $\Gamma$ (mapping variables to
their types) and a predicate environment $\Theta$ (mapping integer-typed
variables to Boolean predicates), expression $e$ will have type $\tau$ if evaluated
in context mode $m$, indicating that the code is in $m$ region.
The operational semantics for \lang is defined as a small-step
transition relation with the judgment $ (\varphi,\heap,e)
\longrightarrow_m (\varphi',\heap',r)$, as shown in \Cref{fig:c-context}.
 Here, $\varphi$ is a
\emph{stack} mapping from variables to values $\evalue{n}{\tau}$ and
$\heap$ is a \emph{heap} that is partitioned into two parts ($\cmode$ and $\umode$ heap regions), each of which
maps addresses (integer literals) to values $\evalue{n}{\tau}$.
The complete set of typing rules and special handling of (NT)-arrays are provided in~\Cref{rem-type,sec:rem-semantics}.

We wrote $\heap(m,n)$ to retrieve the $n$-location heap value in the $m$ heap,
and $\heapup{m}{n}{\evalue{n'}{\tau}}$ 
to update location $n$ with the value $\evalue{n'}{\tau}$ in the $m$ heap.
While heap bindings can change, stack bindings are immutable---once
variable $x$ is bound to $\evalue{n}{\tau}$ in $\varphi$, that binding will not
be updated. 
%We can model mutable stack variables as pointers into the mutable heap.
As mentioned, value $\evalue{0}{\tau}$
represents a $\enull$ pointer when $\tau$ is a pointer type.
Correspondingly, $\heap(m,0)$ should always be undefined.
% 
The relation steps to a \emph{result} $r$, which is either an
expression, a $\enull$ or $\ebounds$ failure, represent an expression right
  after the reduction, a null-pointer dereference or out-of-bounds access,
respectively.
% 
Such failures are a \emph{good} outcome; stuck states
(non-value expressions that cannot transition to a result $r$)
characterizing undefined behavior.
%The context mode $m$ (in $\longrightarrow_{m}$) indicates whether the stepped redex within $e$ was in a $\cmode$ or $\umode$ region.

The rules for the main operational semantics
judgment \emph{evaluation} are given at the bottom of
Fig.~\ref{fig:c-context}.
The first rule takes an expression $e$, decomposes
it into an \emph{evaluation context} $E$ and a sub-expression $e'$
(such that replacing the hole $\Box$ in $E$ with $e'$ would yield
$e$), and then evaluates $e'$ according to the \emph{computation}
  relation $(\varphi,\heap,e') \longrightarrow (\varphi,\heap,e'')$,
whose rules are given along with type rules in Fig.~\ref{fig:type-system-1} (labeled as \rulelab{S-}$X$), discussed
shortly.
The $\mode$ function in Fig.~\ref{fig:c-context}
determines the context mode, i.e., region, that the expression $e'$ locates based on the context $E$.
In \Cref{lst:humantaint}, the function call \code{handle_request} is in $\umode$ region since it is inside an unchecked function \code{server_loop}.
The second rule describes the exception handling 
for possible crashing behaviors in $\umode$ regions.
Operations in $\umode$ region can non-deterministically crash
and the \systemname sandbox mechanism recovers
the program to a safe point ($\evalue{0}{\tau}$)
and continues with the existing program state.
Evaluation contexts $E$ define a standard left-to-right evaluation order.
%(We explain the $\ret{x}{\mu}{e}$ syntax shortly.)
%There are other rules for describing the halts of evaluation to $\enull$ and $\ebounds$ states in \Cref{app:main}.

\myparagraph{Modes, Static Casting, and Subtyping}
In \lang, Context modes $m$ appearing in a type rule determine the code region 
that permits pointer dereferences and value-assignments, which also depends on the pointer modes.
We define a three point lattice $\kappa_1 \le \kappa_2$ \footnote{In typing rule, the lattice is usually used as $\kappa \le m$ as $m$ represents context modes.} to describe such permission, where $\tmode \le \kappa$ and $m \le m$.
This means that a $\tmode$ pointer can be dereferenced and value-assigned in any region, while $\cmode$ and $\umode$ pointers can only perform such operations in $\cmode$ and $\umode$ regions, respectively.
%Pointer modes are also useful in determining if a nested pointer has a valid type. For example, in a nested pointer $\tptr{(... \tptr{\tau}{\kappa_2} ...)}{\kappa_1}$, we require $\kappa_2\le \kappa_1$ to maintain non-exposure.

\lang also provides static casting operations. As described in rule \textsc{T-CastPtr} in \Cref{fig:type-system-1},
an pointer typed expression of type $\tptr{\tau_1}{\kappa_1}$ can be casted to another pointer type \tptr{\tau_2}{\kappa_2},
if \tptr{\tau_1}{\kappa_1} subtypes ($\sqsubseteq_{\Theta}$) to \tptr{\tau_2}{\kappa_2}, i.e., $\tptr{\tau_1}{\kappa_1} \sqsubseteq \tptr{\tau_2}{\kappa_2}$.
In \lang, except that we can cast a $\tmode$ mode pointer to a $\umode$ mode one, all subtyping relations are between two types with the same mode, meaning that $\kappa_1$ and $\kappa_2$ above are mostly the same and the above mode lattice ($\le$) has no business with subtyping.

\begin{minted}[xleftmargin=30pt, mathescape, escapeinside=||, fontsize=\footnotesize]{c}
//_Ptr<int> x; _t_Ptr<int> y; int *z;
z = (int *)y; // This is okay.
x = (_Ptr<int>)y; // Not allowed.
\end{minted}

In the above example, a $\tmode$ mode pointer can be cast to $\umode$ mode but casting $\tmode$ mode to $\cmode$ mode is disallowed.
The complete subtyping relation was described in \Cref{app:le}.
Notice that \texttt{let} statements are immutable in \lang, so the following code is not possible, because variables \code{x} and \code{y} must have the same type in \lang.

\begin{minted}[xleftmargin=30pt, mathescape, escapeinside=||, fontsize=\footnotesize]{c}
//_Ptr<int> x;  _t_Ptr<int> y;
x = y; // Not allowed.
\end{minted}

\myparagraph{Pointer Dereference}
The type and semantic rules for pointer dereference (\textsc{T-Def}, \textsc{S-DefC},
\textsc{S-DefT}, \textsc{S-DefNull} in \Cref{fig:type-system-1})
reflect the key \lang feature, where our type checker directs the insertions of dynamic checks executed in the evaluation stage.
The type rule (\textsc{T-Def}) ensures that pointers are used with the right modes in the right region ($\kappa \le m$).
With the dynamic checks inserted by the compiler, rule \textsc{S-DefNull} ensure that if a $\enull$ pointer is used,
\lang captures the runtime error.
Type and semantic rules for array types and pointer assignments are given in \Cref{rem-type,sec:rem-semantics}.

Rules \textsc{S-DefC} and \textsc{S-DefT} are for $\cmode$ and $\tmode$ mode pointer dereferences, respectively.
In addition to the no $\enull$ check in $\cmode$ mode pointer dereference,
any dynamic heap access of a tainted ($\tmode$) pointer requires a \textit{verification} ($\emptyset;\heap ; \emptyset \vdash_{\umode}\evalue{n_a}{\tau}$), which refers to that the pointer value $n_a$ is well-defined in $\heap(m,n_a)$ and has right type $\tau$.

\myparagraph{Unchecked and Checked Blocks}
The execution of a $\echeckedtext$ or $\euncheckedtext$ block represents 
the context switching from a $\cmode$ to an $\umode$ region, or vice versa,
with its type and semantic rules given in \Cref{fig:type-system-1}.
In this context switching, to guarantee the checked ($\cmode$) pointer non-exposure property, 
checked pointers are not allowed to go cross different regions, which is guaranteed by the predicates 
$\forall x\in\overline{x}\;.\;\neg\cmode(\Gamma(x))$ and $\neg\cmode(\tau)$,
as well as the check that all free variables in the block content $e$ are in $\overline{x}$.
For example, \code{StringAuth} in \Cref{subsub:gencregion} is a trampoline function that disallows
checked pointers as arguments and return values.
The use of the function in the following \code{_T_StringAuth}, which is in $\umode$ region,
cannot legally acknowledges any checked pointers; otherwise, we might expose a checked pointer address to unsafe code regions.
In \systemname, we actually permits the accesses of checked pointers inside \code{StringAuth},
since the function body of a trampoline function is in $\cmode$ region.
More information is given in \Cref{subsub:gencregion}.

\myparagraph{Dependent Function Pointers} %
Rule \textsc{T-Fun} (\Cref{fig:type-system-1}) states the type judgment for
dependent function pointer application, where we represent the result of
replacing all integer bound variables $\overline{x}$ in the type \(\tau\) with
with bound expressions $\overline{e'}$ by $\tau[\overline{e'} / \overline{x}]$
and write $\overline{\tau}[\overline{e'} / \overline{x}]$ to lift the
substitution to every type in \(\overline{\tau}\).
% 
Given an expression $e$ of function pointer type
($\tptr{\tfun{\overline{x}}{\overline{\tau}}{\tau}}{\kappa}$) and arguments
$\overline{e}$ of types $\overline{\tau'}$,
% 
the result of the application will
be of type $\tau[\overline{e'} / \overline{x}]$;
if for each pair of \(\tau'\) and \(\tau''\) in \(\overline{\tau'}\) and
$\overline{\tau}[\overline{e'} / \overline{x}]$, \(\tau'\) is a subtype of
\(\tau''\).
Consider the \code{process_req2} function in
Fig.~\ref{lst:final}, whose parameter type for \code{msg} 
depends on \code{m_1}.
Its function pointer type is 
$\tptr{\tfun{\code{m_1}}{\tint,\tntarray{0}{\code{m_1}}{\texttt{char}}}{\tint}}{\tmode}$.
In \code{handle_request}, the call \code{process_req2(buff, r_len)} binds variable \code{m_1} to \code{r_len}.
After the call returns, \code{m_1}'s scope is ended, so we need to substitute it with \code{r_len} in the final return type
because it might contain \code{m_1}.

\textsc{S-FunC} and \textsc{S-FunT} define the semantics
for $\cmode$ and $\tmode$ mode function pointers, respectively. 
A call to a function pointer $n$ retrieves
 the function definition in $n$'s location in the global function store $\Xi$,
which maps function pointers to
function data $\tau\;(\evalue{\overline{x}}{\overline{\tau}})\;(\kappa,e)$, where
$\tau$ is the return type, $(\evalue{\overline{x}}{\overline{\tau}})$
is the parameter list of variables and their types, 
$\kappa$ determines the mode of the function, and $e$ is the
function body. 
Similar to \heap, the global function store $\Xi$ is also partitioned into
two parts ($\cmode$ and $\umode$ store regions), each of which
maps addresses (integer literals) to the function data described above.
Rule \textsc{S-FunT} defines the tainted version of function call
with the verification process 
$\emptyset;\heap ; \emptyset \vdash_{\umode}\evalue{n}{\tptr{\tau}{\tmode}}$
makes sure that the function in the global store is well-defined and has the right type.

\subsection{Meta Theories}\label{sec:theorem}

% Before we present our main theorems, we need to first
% discuss the meaning what a pointer being well-typed in a given heap
% snapshot $\heap$ means, which is captured by rules in
% Fig.~\ref{fig:const-type}. The variable type rule ($\textsc{T-Var}$)
% simply checks if a given variable has the defined type in $\Gamma$;
% the constant rule ($\textsc{T-Const}$) is slightly more involved.
% First, it ensures that the type annotation $\tau$ does not contain any
% free variables. More importantly, it ensures that the pointer points
% to a location that makes sense in a given heap.
%  
%  
%  The $\size$ function in Fig.~\ref{fig:const-type}
% refers to the \code{sizeof} function in C computing the number of
% bytes for a type.
%  
%  
%  Second, we
% require that any constant ($\evalue{n}{\tau}$) should make sense in
% $\heap$. We develop a recursive predicate $\sigma \vdash n : \tau$ to
% verify if $n$ has $\tau$ in a heap snapshot $\heap$. $\sigma$ is a
% constant set containing the constants that have been verified by the
% relation. For every constant $\evalue{n}{\tau}$, it is either an
% integer $\tint$, an unchecked pointer $\tptr{\omega}{\umode}$,
% zero-valued number ($n=0$), checked in $\sigma$
% ($\evalue{n}{\tptr{\omega}{\cmode}}\in \sigma$); or if it is not the
% above case, then (i) $\heap(n)$ is defined, and (ii) for every heap
% location $n+i$ in the range of the pointer (if $\omega$ is a word
% type, range is $[0,1)$; if $\omega$ is an array type
%   ($\tarray{0}{b_h}{\tau'}$), range is $[0,b_h)$, if $\tau$ is a
%     NT-array type ($\tntarray{0}{b_h}{\tau'}$), range is $[0,b_h+1)$),
%       if $\heap(n+i)=\evalue{n_a}{\tau_a}$, then
%       $\evalue{n_a}{\tau_a}$ satisfies $\sigma \cup \{(n,\tau) \}
%       \vdash n_a : \tau_a$.
%  
%  
% \begin{figure}[t]
% {\small
% \text{Type Rules for Constants and Variables:}
% \begin{mathpar}
%   \inferrule[T-Var]
%       {x : \tau \in \Gamma}
%       {\Gamma;\Theta \vdash_m x : \tau}
%  
%   \inferrule[T-Const]
%       {\fv(\tau) = \emptyset \\ \emptyset \vdash n : \tau}
%       {\Gamma;\Theta\vdash_m \evalue{n}{\tau} : \tau}
% \end{mathpar}
%     
% \text{Rules for Checking Constant Pointers In Heap:}
% \begin{mathpar}
%   \inferrule
%       {}
%       {\sigma \vdash n : \tint}
%  
%   \inferrule
%       {}
%       {\sigma \vdash n : \tptr{\omega}{\umode}}
%  
%   \inferrule
%       {}
%       {\sigma \vdash 0 : \tptr{\omega}{\cmode}}
%  
%   \inferrule
%       {\evalue{n}{\tptr{\omega}{\cmode}}\in \sigma}
%       {\sigma \vdash n : \tptr{\omega}{\cmode}}
%  
%   \inferrule
%       {\forall i \in [0,\size(\omega)) .
%            \sigma \cup \{(n:\tptr{\omega}{\cmode}) \}\vdash \heap(n+i)}
%       {\sigma \vdash n : \tptr{\omega}{\cmode}}
% \end{mathpar}
% }
% \caption{Type Rules for Checking Constants/Variables}
% \label{fig:const-type}
% \end{figure}

% \review{
%  Theorem 1 refers to a program $e$ being well-formed. Unless I've missed
%   something, I didn't see such a definition in the paper.}
% \mwh{This was stale text (dropped); $e$'s well formedness follows from the
%   assumption of well typing; we have added more details about that.}

Here, we discuss our main meta-theoretic results for
\lang: type soundness (progress and preservation),
non-exposure, and non-crashing.
These proofs have been conducted in our Coq model.
Type soundness relies on several \emph{well-formedness} given in \cite{li22checkedc} and \Cref{sec:meta}.
The progress theorem below states that a \lang program can always make a move.

\begin{thm}[Progress]\label{thm:progress}

For any \lang program $e$, heap $\heap$, stack
$\varphi$, type environment $\Gamma$, and variable predicate set $\Theta$
that are all are well-formed, consistent
($\Gamma;\Theta\vdash \varphi$ and $\heap \vdash \varphi$) and well
typed ($\Gamma;\Theta\vdash_{\cmode} e : \tau$ for some $\tau$),
one of the following holds:

\begin{itemize}

\item $e$ is a value ($\evalue{n}{\tau}$).

\item there exists $\varphi'$ $\heap'$ $r$, such that $(\varphi,\heap,e) \longrightarrow_m (\varphi',\heap',r)$.

\end{itemize}
\end{thm}
%{\em Proof:} By induction on the typing derivation.

\noindent
There are two forms of preservation regarding the $\cmode$ and $\umode$ regions.
Checked Preservation states that a reduction step preserves both the
type and consistency of the program being reduced, while
unchecked Preservation states that any evaluation happens at $\umode$ region does not affect the $\cmode$ mode heap.

\begin{thm}[Checked Preservation]
For any \lang program $e$, heap $\heap$, stack
$\varphi$, type environment $\Gamma$, and variable predicate set $\Theta$
that are all are well-formed, consistent
($\Gamma;\Theta\vdash \varphi$ and $\heap \vdash \varphi$) and well
typed ($\Gamma;\Theta\vdash_{\cmode} e : \tau$ for some $\tau$), if there exists $\varphi'$,
$\heap'$ and $e'$, such that $(\varphi,\heap,e)
\longrightarrow_{\cmode} (\varphi',\heap',e')$, then $\heap'$ is
$\cmode$ region consistent with $\heap$ ($\heap \triangleright \heap'$) and there exists
$\Gamma'$ and $\tau'$ that are well formed, $\cmode$ region consistent
($\Gamma';\Theta\vdash \varphi'$ and $\heap' \vdash \varphi'$) and
well typed ($\Gamma';\Theta \vdash_{\cmode} e: \tau'$), where
$\tau'\sqsubseteq_{\Theta} \tau$.
\end{thm}
%{\em Proof:} By induction on the typing derivation.
%\smallskip
\begin{thm}[Unchecked Preservation]
For any \lang program $e$, heap $\heap$, stack
$\varphi$, type environment $\Gamma$, and variable predicate set $\Theta$
that are all are well-formed and well
typed ($\Gamma;\Theta\vdash_{\cmode} e : \tau$ for some $\tau$), if there exists $\varphi'$,
$\heap'$ and $e'$, such that $(\varphi,\heap,e)
\longrightarrow_{\umode} (\varphi',\heap',e')$, then $\heap'(\cmode)=\heap(\cmode)$.
\end{thm}

Using the above theorems, we first show the non-exposure theorem,
where code in $\umode$ region cannot observe a valid checked ($\cmode$) pointer address.

\begin{thm}[Non-Exposure]
For any \lang program $e$, heap $\heap$, stack
$\varphi$, type environment $\Gamma$, and variable predicate set $\Theta$
that are all are well-formed and well
typed ($\Gamma;\Theta\vdash_{\cmode} e : \tau$ for some $\tau$), if there exists $\varphi'$,
$\heap'$ and $e'$, such that $(\varphi,\heap,e)
\longrightarrow_{\umode} (\varphi',\heap',e')$ and $e=E[\alpha(x)]$ and $\mode(E)=\umode$,
where $\alpha(x)$ is some expression (not $\echeckedtext$ nor $\euncheckedtext$) containing variable $x$; 
thus, it is not a checked pointer.
\end{thm}

We now state our main result, {\em non-crashing},
which suggests that a well-typed program can never be \emph{stuck} (expression
$e$ is a non-value that cannot take a step\footnote{Note that
  $\ebounds$ and $\enull$ are \emph{not} stuck expressions---they represent a
  program terminated by a failed run-time check. A program that tries to access $\heap{n}$
  but $\heap$ is undefined at $n$ will be stuck, and violates spatial
  safety.}).

% \review{- There appears to be a slight discrepancy between the blame theorem in Coq and the one in the paper: the paper mentions some e', which I believe should be r. Also, the Coq code has a further disjunct m=Unchecked in the conclusion.}
% \liyi{It is a typo. We will add the thing back that we show that either user uses a unchecked mode to evaluate $e$ or $e$ lives in a context that is an unchecked region. This is a bit due to the space limitation. The semantic rules allow users to input the mode $m$ of evaluating an expression, I just forgot to include the $m$ in the result of the proof statement. }

\begin{thm}[Non-Crashing]\label{thm:blame} For any \lang
  program $e$, heap $\heap$, stack
$\varphi$, type environment $\Gamma$, and variable predicate set $\Theta$
that are well-formed and consistent
($\Gamma;\Theta\vdash \varphi$ and $\heap \vdash \varphi$),
if $e$ is well-typed ($\varphi;\Theta\vdash_{\cmode} e :
\tau$ for some $\tau$) and there exists
$\varphi_i$, $\heap_i$, $e_i$, and $m_i$ for $i\in [1,k]$, such that
$(\varphi,\heap,e) \longrightarrow_{m_1} (\varphi_1,\heap_1,e_1)\longrightarrow_{m_2} ...\longrightarrow_{m_k} (\varphi_k,\heap_k,r)$, then $r$ can never be \emph{stuck}.
\end{thm}

%{\em Proof:} By induction on the number of steps of the \checkedc
%evaluation ($\longrightarrow_m^*$), using progress and preservation to
%maintain the invariance of the assumptions.


\ignore{
\subsection{Semantics}\label{sec:semantics}

% The semantics
% gives an independent account of spatial safety in \lang by
% checking pointer bounds based on the annotations carried on types at
% run-time.  While this account makes clear that bounds checking occurs
% as expected, it suggests an implementation that uses fat pointers to
% carry bounds.  We resolve this tension in the subsequent section on
% compilation and show that an implementation faithful to the semantics
% can be obtained without fat pointers.  
% \review{repeat that the stack is immutable at this point?}
% \liyi{Is it? Is the stack immutable? What does the immutable mean? 
%   In a stack, the variable values can be changed? Right?
%   The pointer address itself cannot be changed once it is created, but the stack variable content can be updated?  }
% \mwh{It certainly seems to be immutable: Your create stack frames
%   using let binding, and the let-bound variables will always be bound
%   to the same things. I.e., stack cells are immutable.}

% \review{this raises a fair amount of questions regarding the treatment of the
%   NULL pointer at this stage of the paper... is it modeled as 0, as returned by
%   `malloc`? are dynamic checks inserted by CheckedC to guarantee that no NULL
%   pointer is dereferenced?}
% \mwh{Yes, it is modeled as 0, and the semantics checks for
%   dereferences of 0. }

Here, we discuss the \lang operational semantics (\Cref{fig:semantics}); 
mainly focusing on the new changes on top of \checkedc in \cite{li22checkedc} with function pointers, modes, and function calls.
The other type and semantic rules about (NT)-arrays are given in \cite{li22checkedc} and \Cref{sec:literal-pointer-typing}.

%The typing judgment has the form $\Gamma;\Theta\vdash_m e : \tau$,
%which states that in a type environment $\Gamma$ (mapping variables to
%their types) and a predicate environment $\Theta$ (mapping integer-typed
%variables to Boolean predicates), expression $e$ will have type $\tau$ if evaluated
%in context mode $m$. Key rules for this judgment are given in
%Fig.~\ref{fig:type-system-1},

The operational semantics for \lang is defined as a small-step
transition relation with the judgment $ (\varphi,\heap,e)
\longrightarrow_m (\varphi',\heap',r)$.
 Here, $\varphi$ is a
\emph{stack} mapping from variables to values $\evalue{n}{\tau}$ and
$\heap$ is a \emph{heap} that is partitioned into two parts ($\cmode$ and $\umode$ heaps), each of which
maps addresses (integer literals) to values $\evalue{n}{\tau}$.

\myparagraph{Pointers, Contexts, and Modes}
A $\cmode$ pointer is mapped to a heap location in the $\cmode$ heap, 
while a $\tmode$ and $\umode$ pointer represents a $\umode$ heap location.
We wrote $\heap(m,n)$ to retrieve the $n$-location heap value in the $m$ heap,
and $\heapup{m}{n}{\evalue{n'}{\tau}}$ 
to update location $n$ with the value $\evalue{n'}{\tau}$ in the $m$ heap.
It is worth noting that \systemname is not a fat-pointer system;
thus, in every heap update, the value type annotation remains the same through program executions.
% 
\mz{Does a ``non-fat pointer'' system cause the type preservation of heap
  values?
  % 
  The story seems to be that you design the system in a certain way s.t. heap
  value types are unchanged, which allows you to erase the type.
  % 
  And, from the type erasure property, we know that we don't need fat pointers.
}
% 
Additionally, for both stack and heap, 
we ensure $\fv(\tau)=\emptyset$ for all the value type annotations $\tau$.

While heap bindings can change, stack bindings are immutable---once
variable $x$ is bound to $\evalue{n}{\tau}$ in $\varphi$, that binding will not
be updated. 
We can model mutable stack variables as pointers into the
mutable heap.
As mentioned, value $\evalue{0}{\tau}$
represents a $\enull$ pointer when $\tau$ is a pointer type.
Correspondingly, $\heap(m,0)$ should always be undefined.
% 
The relation steps to a \emph{result} $r$, which is \mzs{either} \mzr{one of} an
expression, a $\enull$ or $\ebounds$ failure, represent \mzr{an expression right
  after the reduction}, a null-pointer dereference or out-of-bounds access,
respectively.
% 
Such failures are a \emph{good} outcome; stuck states
(non-value expressions that cannot transition to a result $r$)
characterizing undefined behavior.
%
% 
The context mode $m$ (in $\longrightarrow_{m}$) indicates whether the
stepped redex within $e$ was in a $\cmode$ or $\umode$ region.

The rules for the main operational semantics
judgment \emph{evaluation} are given at the bottom of
Fig.~\ref{fig:c-context}.
The first rule takes an expression $e$, decomposes
it into an \emph{evaluation context} $E$ and a sub-expression $e'$
(such that replacing the hole $\Box$ in $E$ with $e'$ would yield
$e$), and then evaluates $e'$ according to the \emph{computation}
  relation $(\varphi,\heap,e') \longrightarrow (\varphi,\heap,e'')$,
whose rules are given in Fig.~\ref{fig:semantics}, discussed
shortly.
The $\mode$ function  at the bottom of Fig.~\ref{fig:c-context}
determines the context mode that the expression $e'$ locates based on the context $E$.
In \Cref{lst:humantaint}, the function call expression \code{read_msg} has $\umode$ mode since it is inside a tainted function.
The second rule describes the exception handling 
for possible crashing behaviors in unchecked regions.
A $\umode$ mode operation can non-deterministically crash
and the \systemname sandbox mechanism recovers
the program to a safe point ($\evalue{0}{\tau}$)
and continues with the existing program state.
Evaluation contexts $E$ define a standard left-to-right evaluation order. (We explain the
$\ret{x}{\mu}{e}$ syntax shortly.)
%There are other rules for describing the halts of evaluation to $\enull$ and $\ebounds$ states in \Cref{app:main}.

Fig.~\ref{fig:semantics} shows selected rules for the computation relation.
The rules for pointer related operations---\textsc{S-DefC},
\textsc{S-DefT}, \textsc{S-DefNull}, and \textsc{S-Cast}.
The type rule for deference operations is given as rule \rulelab{T-Def} in \Cref{fig:type-system-1}.
The first three define the semantics of deference and assignment operations.
Rule \textsc{S-DefNull} transitions attempted null-pointer
dereferences to $\enull$, whereas \textsc{S-DefC} dereferences a $\cmode$-mode
non-null (single) pointer.
When $\enull$ is returned by the
computation relation, the evaluation relation halts the entire
evaluation with $\enull$ (using a rule not shown in Fig.~\ref{fig:c-context}); it
does likewise when $\ebounds$ is returned (see \Cref{sec:rem-semantics}).
%\textsc{S-AssignArrC} assigns to an array as long as 0 (the point of
%dereference) is within the bounds designated by the pointer's annotation
%and strictly less than the upper bound. 
\textsc{S-DefT} is similar to \textsc{S-DefC} for tainted pointers.
Any dynamic heap access of a tainted pointer requires a \textit{verification}.
Performing such a verification equates to performing a literal type check for a pointer constant in \Cref{fig:const-type}.
We explain this shortly below for \emph{constant validity checks}.
For now, the verification step, e.g. $\emptyset;\heap ; \emptyset \vdash_{\umode}\evalue{n_a}{\tau}$ in \textsc{S-DefC},
refers to that the value $n_a$ is well-defined in $\heap(m,n_a)$ and has type $\tau$, if $\tau$ is a pointer.
Static casts of a literal $n\!:\!\tau'$ to a type $\tau$ are handled
by \textsc{S-Cast}. In a type-correct program, such casts are
confirmed safe by the type system no matter
if the target is a $\tmode$ or $\cmode$ pointer. To evaluate a cast, the rule
updates the type annotation on $n$. Before doing so, it must
``evaluate'' any variables that occur in $\tau$ according to their
bindings in $\varphi$. For example, if $\tau$ was
$\tarrayptr{0}{x+3}{\tint}{\cmode}$, then $\varphi(\tau)$ would
produce $\tarrayptr{0}{5}{\tint}{\cmode}$ if $\varphi(x) = 2$.
%The full formalism, including \kw{struct}
%and null-terminated bound widening pointer operations, is given in \Cref{app:main}.

%\footnote{This approach is that of the PLT Redex model of \lang; the Coq
%development uses a slightly simpler syntax to achieve the same
%effect.}
% \review{the special case raises questions, e.g. why is this syntax-driven and
%   not type-driven? }
% \liyi{This describes the semantic transition rules. We are using context evaluation framework to define the transition rules as the $E$ definition in Fig.3. like $\frac{x \Rightarrow y}{x+z \Rightarrow y + z}$, I don't know how type-driven can help us define translation rules.  }
% \mwh{Don't follow the above. I don't see this ``context transition
%   rule'' anywhere, and I'm not sure how it would fire, if we had it.}
% \liyi{The comment seems to confuse the meaning of the text about the if-then-else rules. Making the rule specific will help. }



\begin{DIFnomarkup}
 \begin{figure}[t]
 {\small

 \begin{mathpar}
   \inferrule
       {}
       {\Theta;\heap;\sigma \vdash_m n : \tint}

   \inferrule
       {}
       {\Theta;\heap;\sigma \vdash_m 0 : \tptr{\omega}{\kappa}}

   \inferrule
       {(m = \cmode \Rightarrow \kappa \neq \cmode) \\\\ (m=\umode \Rightarrow \kappa = \umode)}
       {\Theta;\heap;\sigma \vdash_{\cmode} n : \tptr{\omega}{\tmode}}
  
   \inferrule
       {(\evalue{n}{\tptr{\omega}{\kappa}})\in \sigma}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{\omega}{\kappa}}


   \inferrule
       {\tptr{\omega'}{\kappa'} \sqsubseteq_{\Theta} \tptr{\omega}{\kappa} 
            \\ \Theta;\heap;\sigma \vdash_m n : \tptr{\omega'}{\kappa'}}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{\omega}{\kappa}}

   \inferrule
       { \kappa \le m 
     \\\Xi(m,n)=\tau\;(\evalue{\overline{x'}}{\overline{\tau}})\;(\kappa,e)
       \\  \overline{x} = \{x|(x:\tint) \in (\overline{x'}:\overline{\tau}) \}}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{(\tfun{\overline{x}}{\overline{\tau}}{\tau})}{\kappa}}
  
   \inferrule
       {\neg\funptr(\omega)\\ \kappa \le m\\
        \forall i \in [0,\size(\omega)) \;.\;
            \Theta;\heap;(\sigma \cup \{(n:\tptr{\omega}{\kappa})) \}\vdash_m \heap(m,n+i)}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{\omega}{\kappa}}
 \end{mathpar}
 }
{\footnotesize
\[
\begin{array}{l} 
\funptr(\tfun{\overline{x}}{\overline{\tau}}{\tau}) = \texttt{true}
\qquad
\funptr(\omega) = \texttt{false}\;\;{[\emph{owise}]}
\end{array}
\]
}
 \caption{Verification/Type Rules for Constants}
 \label{fig:const-type}
 \end{figure}
\end{DIFnomarkup}


% SKIPPING THIS
\iffalse

\myparagraph{Type Equality and Subtyping and Casting}
%
In \lang, the type equability ($=_{\Theta}$) and subtype ($\sqsubseteq$) relations are given in \Cref{fig:checkc-subtype}.
We provide some example descriptions here.
Type equality $\tau=_{\Theta}\tau'$
is a type construct equivalent relation defined by the bound equality ($=_{\Theta}$) in (NT-)array pointer types
and the alpha equivalence of two function types;
i.e., two (NT-)array pointer types $\tallarrayb{\bvar}{\tau} $ and $ \tallarrayb{\bvar'}{\tau'}$ are equivalent, if 
$\bvar =_{\Theta} \bvar'$ and $\tau=_{\Theta}\tau'$; two function types 
$\tfun{\overline{x}}{\overline{\tau}}{\tau} $ and $ \tfun{\overline{y}}{\overline{\tau'}}{\tau'}$
are equivalent, if we can find a same length (as $\overline{x}$ and $\overline{y}$) variable list $\overline{z}$ that is substituted for $\overline{x}$ and $\overline{y}$ in $\overline{\tau} \to {\tau}$ and $\overline{\tau'} \to {\tau'}$, resp.,
and the substitution results are equal.

The \textsc{T-CastPtr} rule in \Cref{fig:type-system-1}
permits casting from an expression of type $\tau'$ to a checked pointer when
$\tau' \sqsubseteq \tptr{\tau}{\cmode}$. This subtyping relation
$\sqsubseteq$ is built on the type equality ($\tau =_{\Theta} \tau'\Rightarrow\tau \sqsubseteq_{\Theta} \tau'$). 
The rule  ($0\le b_l \wedge b_h \le 1 \Rightarrow \tptr{\tau}{m}\sqsubseteq
\tarrayptr{b_l}{b_h}{\tau}{m}$) permits treating a singleton
pointer as an array pointer with $b_h\le 1$ and $0 \le b_l$.
Two function pointer types are subtyped ($\tptr{\tfun{\overline{x}}{\overline{\tau}}{\tau}}{\kappa} \sqsubseteq_{\Theta} \tptr{\tfun{\overline{x}}{\overline{\tau'}}{\tau'}}{\kappa}$), 
if the output type are subtyped ($\tau\sqsubseteq_{\Theta}\tau'$) and the argument types are reversely subtyped ($\overline{\tau'}\sqsubseteq_{\Theta}\overline{\tau}$).
%There is another casting rule in \Cref{app:main} stating that
% users are free to cast types in unchecked code regions, since unchecked regions can contain C code.

\begin{DIFnomarkup}
 \begin{figure}[t]
 {\small

 \begin{mathpar}
   \inferrule
       {}
       {\Theta;\heap;\sigma \vdash_m n : \tint}

   \inferrule
       {}
       {\Theta;\heap;\sigma \vdash_m 0 : \tptr{\omega}{\kappa}}

   \inferrule
       {(m = \cmode \Rightarrow \kappa \neq \cmode) \\\\ (m=\umode \Rightarrow \kappa = \umode)}
       {\Theta;\heap;\sigma \vdash_{\cmode} n : \tptr{\omega}{\tmode}}
  
   \inferrule
       {(\evalue{n}{\tptr{\omega}{\kappa}})\in \sigma}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{\omega}{\kappa}}


   \inferrule
       {\tptr{\omega'}{\kappa'} \sqsubseteq_{\Theta} \tptr{\omega}{\kappa} 
            \\ \Theta;\heap;\sigma \vdash_m n : \tptr{\omega'}{\kappa'}}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{\omega}{\kappa}}

   \inferrule
       { \kappa \le m 
     \\\Xi(m,n)=\tau\;(\evalue{\overline{x'}}{\overline{\tau}})\;(\kappa,e)
       \\  \overline{x} = \{x|(x:\tint) \in (\overline{x'}:\overline{\tau}) \}}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{(\tfun{\overline{x}}{\overline{\tau}}{\tau})}{\kappa}}
  
   \inferrule
       {\neg\funptr(\omega)\\ \kappa \le m\\
        \forall i \in [0,\size(\omega)) \;.\;
            \Theta;\heap;(\sigma \cup \{(n:\tptr{\omega}{\kappa})) \}\vdash_m \heap(m,n+i)}
       {\Theta;\heap;\sigma \vdash_m n : \tptr{\omega}{\kappa}}
 \end{mathpar}
 }
{\footnotesize
\[
\begin{array}{l} 
\funptr(\tfun{\overline{x}}{\overline{\tau}}{\tau}) = \texttt{true}
\qquad
\funptr(\omega) = \texttt{false}\;\;{[\emph{owise}]}
\end{array}
\]
}
 \caption{Verification/Type Rules for Constants}
 \label{fig:const-type}
 \end{figure}
\end{DIFnomarkup}

\myparagraph{Constant Validity}
Rules \textsc{T-ConstU} and \textsc{T-ConstC} in \Cref{fig:type-system-1}
describe type assumptions for constants appearing in a program.
$\neg \cmode(\tau)$ judges that a constant pointer 
in an unchecked region cannot be of a checked type.
The restriction ensures that programmers 
cannot guess a checked pointer address and utilize it in an unchecked region in \systemname.
In rule \textsc{T-ConstC}, we requires a static 
verification procedure for validating a constant pointer in \Cref{fig:const-type}. 

The verification process $\Theta;\heap;\sigma \vdash_m n : \tau$
validates the constant $\evalue{n}{\tau}$, 
where $\heap(m)$ is the initial heap that the constant resides on and
$\sigma$ is a set of constant assumed to be checked.
A global function store $\Xi(m)$ is also required to check the validity of a function pointer.
A valid function pointer should appear in the right store region ($\cmode$ or $\umode$)
and the address stores a function with the right type.
The last rule in \Cref{fig:const-type} describes the validity check for a non-function pointer, 
where every element in the pointer range ($[0,\size(\omega))$) should be well
typed.
A checked pointer checks validity in type step as rule \textsc{T-ConstC},
while a tainted/unchecked pointer does not check for such during the type checking.
Tainted pointers are validated through the validity check in dynamic execution as we mentioned in rule \rulelab{S-DefT}.

% \review{Fig4: it was hard to tell which cases were stuck states, or could reduce
%   owing to a rule that was not shown}
% \mwh{Stuck states are those where the expression is a non-value and
%   not $\enull$ or $\ebounds$. Updated III-B and III-D.}
% \review{Fig4: can the rules be presented in the same order they were introduced in
%   the paper?}
% \liyi{ Reordered }

% \review{Fig4: S-FUN: $\vec\tau_a$ seems unused; why?}
% \liyi{the list of $\tau_a$ is a list of input argument types. These
%   are used during type checking, but not during evaluation (as is
%   typical).} 

% LEO: This has an overfull line...?



% Below, we introduce low-level transition semantics for some case operations. The design of the low-level individual operation semantics is carefully engineered to perform match our compiler's behavior, such as correctly characterizing the bound widening behaviors for NT-array pointers, even though it is written in terms of fat-pointer formalization.
% \review{- on page 6, section IIIC, paragraph "Pointer Access" mentions that checked pointers cannot be dereferenced in unchecked blocks - this looks funny, shouldn't it be the other way around? The Coq code contains the hypothesis m'=Unchecked -> m Unchecked in various rules of definition well-typed (BoundCheckedC, line 669; rule TyDeref in the code seems closest to the figure's T-DefArr and T-Def in the appendix, although it's a bit concerning that there's no 1-to-1 correspondence of the rules in the code and the paper).
% }
% \liyi{Yeah. It is another typo. It should be the other way around.  }

\myparagraph{Unchecked and Checked Blocks}
%
During the type checking,
Both $\echecked{\overline{x}}{e}$ and $\eunchecked{\overline{x}}{e}$
check all free variables in $e$ are within $\overline{x}$;
the types for $\overline{x}$ and the final return type $\tau$ of $e$ have no checked pointers.
Otherwise, it violates the non-exposure safety.
For example, \code{read_msg} in the \code{handle_request} function is tainted in \Cref{lst:humantaint},
if any argument for \code{handle_request} is a checked pointer, 
it means that we are exposing a checked pointer address to unsafe regions.
% 
\mzu{A $\echeckedtext$ or $\euncheckedtext$ block represents 
  the context switching from a checked to an checked region, or vice versa.
}
% 
\mz{An action + checked/unchecked block represents the switching.}
% 
We need to make sure no checked pointers are \mzs{information} exposed to unsafe code regions.
as rules \textsc{S-Unchecked} and \textsc{S-Checked} in \Cref{fig:semantics}.
% 
\mz{This paragraph is not that cohesive.}
% 

\myparagraph{Let Bindings and Dependent Function Pointers}
%
Rules \textsc{T-Let} and \textsc{T-LetInt} in in \Cref{fig:type-system-1} type a $\elettext$ expression, which also admits
type dependency. 
In particular, the result of evaluating a $\elettext$ expression
may have a type that refers to one of its bound variables (e.g., if
the result is a checked pointer with a variable-defined bound). 
If so, we must substitute away this variable once it goes out of scope (\textsc{T-LetInt}). 
Note that we restrict the expression $e_1$ to syntactically match the
structure of a Bounds expression $b$ (see Fig.~\ref{fig:checkc-syn}).
Rule \textsc{T-RetInt} types a $\erettext$ expression when $x$ is of type $\tint$.
$\erettext$ does not appear in source programs but is introduced by the semantics when
evaluating a let binding (rule \textsc{S-Let} in
Fig.~\ref{fig:semantics}). 
%\liyi{why? }
% After the evaluation of a let binding a variable $x$ concludes,
%we need to restore any prior binding of $x$, which is either
%$\bot$ (meaning that there is no $x$ originally) or some value
%$\evalue{n}{\tau}$.

Rule \textsc{T-Fun} in \Cref{fig:type-system-1} is the dependent function call rule. 
Given a function pointer type ($\tptr{\tfun{\overline{x}}{\overline{\tau}}{\tau}}{\kappa}$)
from a type-check for $e$ and the types $\overline{\tau'}$ from the argument type checks for $\overline{e}$,
we confirm that each of $\overline{\tau'}$ is
a subtype of the corresponding one in $\overline{\tau}[\overline{e'} / \overline{x}]$,
which replaces possible integer bound variables $\overline{x}$ with bound expressions $\overline{e'}$.
The final result type is the defined target type $\tau$ appearing in the function pointer type
also with such replacement, written as $\tau[\overline{e'} / \overline{x}]$.
Consider the \code{process_req2} function in
Fig.~\ref{lst:final}; its parameter type for \code{msg} 
depends on \code{m_1}. The \textsc{T-Fun} rule will substitute 
\code{n} with the argument at a call-site.
The semantics manages variable scopes using the special $\erettext$
form. \textsc{S-Let} evaluates to a configuration whose expression is
$\ret{x}{\evalue{n}{\tau}}{e})$. We keep $\varphi$ unchanged
and remember $x$ and its new value $\evalue{n}{\tau}$
in $e$'s scope that is defined by the $\erettext$ operation.
Every time when evaluation proceeds on $e$ (rule \textsc{S-RetCon}),
we install the stack value $\evalue{n}{\tau}$ for $x$ in $\varphi$ for the current scope.
After one-step evaluation is completed, 
we store $x$'s change in the result $\erettext$ operation $\ret{x}{\varphi'(x)}{e'})$,
and restore $x$'s outer score value $\varphi(x)$ in $\varphi'$. 
This procedure continues until $e'$ becomes a literal
$n\!:\!\tau$, in which case \textsc{S-RetEnd} removes the $\kw{ret}$ frame and returns
the literal. 

\textsc{S-FunC} and \textsc{S-FunT} are
for $\cmode$ and $\tmode$ mode function pointers, respectively. 
A call to a function pointer $n$ retrieves
 the function definition in $n$'s location in the global function store $\Xi$,
which maps function pointers to
function data $\tau\;(\evalue{\overline{x}}{\overline{\tau}})\;(\kappa,e)$, where
$\tau$ is the return type, $(\evalue{\overline{x}}{\overline{\tau}})$
is the parameter list of variables and their types, 
$\kappa$ determines the mode of the function, and $e$ is the
function body. 
Similar to \heap, the global function store $\Xi$ is also partitioned into
two parts ($\cmode$ and $\umode$ stores), each of which
maps addresses (integer literals) to the function data described above.

\systemname{} has dependent functions, whose semantic explaination is given in \Cref{appx:add-type-sem}.
Note that the \textsc{S-FunC} and \textsc{S-FunT} rules replace the
  annotations $\overline{\tau_a}$ with
  $\overline{\tau}$ (after instantiation) from the function's
  signature. Using $\overline{\tau_a}$ when executing the body of
the function has no impact on the soundness of \lang, but will violate
Theorem~\ref{simulation-thm}, which we introduce in Sec.~\ref{sec:compilation}.
Rule \textsc{S-FunT} defines the tainted version of function call semantics.
In such case, the verification process 
$\emptyset;\heap ; \emptyset \vdash_{\umode}\evalue{n}{\tptr{\tau}{\tmode}}$
makes sure that the function in the global store is well-defined and has the right type.

 %  For this rule and
% \textsc{S-StrWiden}, this widening persists in the current stack
% frame. When $x$ goes out of scope, .

% \textsc{S-IfNTF} does not widen when seeing null; rule
% \textsc{S-IfNTNot} sees a non-null character, but the pointer is not
% at its upper bound, so the bounds cannot be widened. 

% \ignore{
% Fig.~\ref{fig:semantics} provides the low-level semantic rules for operations involving NT-array pointers, mainly, the $\estrlentext$ and $\eiftext$ operations. The semantics has concurred the ambiguity in the \checkedc specification, e.g., we define the exact behavior of the $\estrlentext$ operation to return the length between the current pointer position and the first null-character.
% We also utilize new technique in our compiler so that the scope of the bound widening behavior in our formalization is a little longer. More details are in Sec.~\ref{sec:compilation}.

% The first rule defines the evaluation behavior of a $\estrlentext$ operation. Given a pointer $x$ with its type $\tntarrayptr{0}{n_h}{\tau}{m}$, the application of such operation takes the address of the pointer $x$, and search incrementally the heap positions next to the address $x$ until we find a $0$ value (representing a null character). We return the value $n_a$ as the length, and update the bound information in the stack for $x$. In the compilation, we use a ghost variable to record such bound changes without using fat-pointer implementations.

% The last three rules in Fig.~\ref{fig:semantics} describe the semantic behaviors of an $\eiftext$ branching operation when the Boolean guard is a dereference of an NT-array pointer. The first one states that if the type upper bound of the pointer $x$ is $0$, and the pointer data value $n_a$ is not $0$, we can conclude that the upper bound is not the last position of the NT-array pointer, so we can then update $1$ in the upper bound while jump to the $\etrue$ branch. The second rule describes that we do not extend the upper bound if the upper-bound of the type of $x$ is not zero because we know that we are not in the NT-array's last position. The third rule describes the behavior of jumping to the $\efalse$ branch when the pointer content is $0$. In this case, we also do not need to increase the upper-bound of the type of $x$.}

\fi
\subsection{Compilation}\label{sec:compilation}

As we have shown in \Cref{fig:overview}, the \systemname compiler utilizes the sandbox mechanism \cite{rul2009towards} and the \checkedc compiler \cite{li22checkedc} to compile programs. Here, we introduce how \systemname compiles a program into these two components.

\begin{figure}[t!]
{\small
\hspace*{-0.5em}
\begin{tabular}{|c|c|c|c|}
\hline
& \cmode & \tmode & \umode \\
\hline
& \textsc{CBox} / \textsc{Core} & \textsc{CBox} / \textsc{Core} & \textsc{CBox} / \textsc{Core} \\
\hline
\cmode & $\estar{x}$ / $\getstar{\cmode}{x}$ 
 & $\texttt{sand\_get}(x)$ / $\getstar{\umode}{x}$ &  $\times$ \\
\hline
\umode & $\times$
 & $\estar{x}$ / $\getstar{\umode}{x}$ &  $\estar{x}$ / $\getstar{\umode}{x}$ \\
\hline
\end{tabular}

}
\caption{Compiled Targets for Dereference}
\label{fig:flagtable}
\end{figure}

In \systemname, context and pointer modes determine the particular heap/function store that a pointer points to,
i.e., $\cmode$ pointers point to checked regions, while $\tmode$ and $\umode$ pointers point to unchecked regions.
Unchecked regions are associated with a sandbox mechanism that permits exception handling of potential memory failures.
In the compiled LLVM code, pointer access operations have different syntaxes when the modes are different. 
\Cref{fig:flagtable} lists the different compiled syntaxes of a deference operation ($\estar{x}$) for the compiler implementation (\textsc{CBox}, stands for \systemname) and formalism (\textsc{Core}, stands for \lang). The columns represent different pointer modes and the rows represent context modes.
For example, when we have a $\tmode$-mode pointer in a $\cmode$-mode region, we compile a deference operation to the sandbox pointer access function ($\texttt{sand\_get}(x)$) accessing the data in the \systemname implementation. In \lang, we create a new deference data-structure on top of the existing $\estar{x}$ operation (in LLVM): $\getstar{m}{x}$. If the mode is $\cmode$, it accesses the checked heap/function store; otherwise, it accesses the unchecked one.

We now show how \lang deals with pointer modes, mode switching and function pointer compilations, 
with no loss of expressiveness
as the \checkedc contains the erase of annotations in \cite{li22checkedc} and \Cref{appx:comp1}.
For the compiler formalism, 
we present a compilation algorithm that converts from
\lang to \elang, an untyped language without metadata
annotations, which represents an intermediate layer we build on LLVM for simplifying compilation. 
In \elang, the syntax for deference, assignment, malloc, function calls are: $\getstar{m}{e}$, $\elassign{m}{e}{e}$, 
$\emalloc{m}{\omega}$, and $\elcall{m}{e}{\overline{e}}$.
The algorithm sheds
  light on how compilation can be implemented in the real Checked C
  compiler, while eschewing many vital details (\elang has many 
  differences with LLVM IR).


%This section shows how \systemname deals with 
%annotations can be safely erased: using static information a compiler
%can insert code to manage and check bounds metadata, with no loss of
%expressiveness. We present a compilation algorithm that converts from
%\lang to \elang, an untyped language without metadata
%annotations. The syntax and semantics \elang
  %closely mirrors that of \lang; it differs only in that literals lack
  %type annotations and its operational rules perform no
  %bounds and null checks, which are instead inserted during
  %compilation. Our compilation algorithm is evidence that \lang's
  %semantics, despite its apparent use of fat pointers, faithfully
  %represents Checked C's intended behavior. The algorithm also sheds
  %light on how compilation can be implemented in the real Checked C
  %compiler, while eschewing many important details (\elang has many 
  %differences with LLVM IR).

Compilation is defined by extending \lang's
typing judgment as follows:
\[\Gamma;\Theta;\rho \vdash_m e \gg \dot e:\tau\]
There is now a \elang output $\dot e$ and an input $\rho$, which maps
each (NT-)array pointer variable to its mode and
each variable \code{p} to a pair of \emph{shadow
  variables} that keep \code{p}'s up-to-date upper and lower bounds. 
These may differ from the bounds in \code{p}'s type due to bounds
widening.\footnote{Since lower bounds are never widened, the
  lower-bound shadow variable is unnecessary; we include it for uniformity.} 

% When $\Gamma$,$\Theta$ and $\rho$ are all empty, we write $e \gg \dot e$ rather than the
% complete judgment, implicitly assuming that $e$ is a well-typed and closed
% term.

We formalize rules for this judgment in PLT Redex~\cite{pltredex},
following and extending our Coq development for \lang. To give
confidence that compilation is correct, we use Redex's property-based
random testing support to show that compiled-to $\dot e $ simulates
$e$, for all $e$.

\myparagraph{Checked and Unchecked Blocks}
%
In the \systemname implementation,
$\euncheckedtext$ and $\echeckedtext$ blocks 
are compiled as context switching functions provided by the sandbox mechanism.
We compile $\eunchecked{\overline{x}}{e}$ to 
$\texttt{sandbox\_call}(\overline{x},e)$, where we call the sandbox 
to execute expression $e$ with the arguments $\overline{x}$.
$\echecked{\overline{x}}{e}$ is compiled to 
$\texttt{callback}(\overline{x},e)$, where we perform 
a \texttt{callback} to a checked block code $e$ inside a sandbox.
In \systemname, we adopt an aggressive execution scheme that
directly learns pointer addresses from compiled assembly to make the $\texttt{callback}$ happen.
In the formalism, we rely on the type system to 
guarantee the context switching without creating the extra function calls for simplicity.

%Fig.~\ref{fig:compilationexample} shows how an invocation of
%\code{strlen} on a null-terminated string is compiled into C
%code. Each dereference of a checked pointer requires a null check
%(See \textsc{S-DefNull} in Fig.~\ref{fig:semantics}), which the
%compiler makes explicit: Line~$3$ of the generated code has the null
%check on pointer \code{p} due to the \code{strlen},
%  and a similar check happens
%  at line~$8$ due to the pointer arithmetic on \code{p}.
%Dereferences also require bounds checks: line~$2$ checks \code{p} is
%in bounds before computing \code{strlen(p)}, while line~$10$ does
%likewise before computing \code{*(p+1)}.

\myparagraph{Function Pointers and Calls}
%
Function pointers are managed similarly to normal pointers,
but we insert checks to check if the pointer address is not null in 
the function store instead of heap, and whether or not the type is correctly represented, 
for both $\cmode$ and $\tmode$ mode pointers 
\footnote{$\cmode$-mode pointers are checked once in the beginning and $\tmode$-mode pointers are checked every time when use}.
For example, in compiling the \code{read_msg} function in \Cref{lst:humantaint},
we place a check \code{verify_fun(read_msg, not_null(c, p_lo, p_hi) && type_match)},
The compilation of function calls (compiling to $\elcall{m}{e}{\overline{e}}$) 
is similar to the manipulation of pointer access operations in \Cref{fig:flagtable}.
The other compilation rules are given in \Cref{appx:add-type-sem}.
}
