\section{Overview}
\label{sec:overview}

\begin{listing}[t!]
  \begin{tabular}{c c}
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/orig1.c}
    \end{minipage} &
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/orig2.c}
    \end{minipage} %\\
   %(a) Original C code & (b) After initial conversion.\\
  \end{tabular}
\caption{C program snippet of a simple network server with an arbitrary memory write vulnerability indicated by~\realbug.}
\label{lst:comb}
\end{listing}

\begin{listing}[t!]
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/firstrun.c}
\caption{Pointers in~\lst{lst:comb} annotated (manually or through automated tools like~\threec) with Checked Types.}
\label{lst:initialconv}
\end{listing}

\begin{listing}[t!]
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/humanannotations.c}
\caption{Initial annotations of tainted functions in~\lst{lst:comb}.}
\label{lst:humantaint}
\end{listing}

\begin{listing}[t!]
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/humanadjustments.c}
\caption{Additional tainted pointers annotations to~\lst{lst:comb} according to typing rules.}
\label{lst:humanadjust}
\end{listing}

\begin{listing}[t!]
  \begin{tabular}{c c}
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/conv1.c}
    \end{minipage} &
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, highlightlines={1-19}, highlightcolor=taintcolor, escapeinside=||, fontsize=\tiny{}]{c}{examples/conv2.c}
    \end{minipage} %\\
   %(a) Original C code & (b) After initial conversion.\\
  \end{tabular}
\caption{Final annotated program of~\lst{lst:comb} with~\textcolor{taintcolor}{tainted} and~\textcolor{checkcolor}{checked} types. The~\colorbox{taintcolor}{highlighted} functions will be executed in a sandbox.}
\label{lst:final}
\end{listing}

\input{figures/overview}

\Cref{fig:overview} shows the interaction between various components of~\systemname{}.
Given an appropriately annotated source program and a sandbox configuration, our system creates an executable such that all tainted functions and data will reside in a sandbox and the~\cregion (non-sandboxed) is not affected by the code in the sandbox.
We will present an overview of the~\systemname{} from a developer perspective and the details of individual components in the later sections.

%\Cref{fig:overview} provides the compiler structure of \systemname. The \systemname type checker compiles a \systemname program by partitioning the different program regions, i.e., $c$ and $uc$ regions, as well as different pointers, i.e., checked, unchecked and tainted pointers. Any $uc$ region pointers are executed within a sandbox, while checked pointers are executed via the \checkedc compiler within the checked region.

%\Cref{sec:formal} provides the formalism of the different compiler components.
%Converting a C/checked-c program to \systemname is a two-step process that involves identifying unsafe/unchecked regions described in \Cref{subsec:identifyregionstosbx} followed by making the \systemname changes described in \Cref{subsec:moveregionstosbx}.  
\subsection{Running Example}
\label{subsec:identifyregionstosbx}
to explain changes required by the \systemname compiler.The~\lst{lst:comb} shows the C code of the redacted version of a simple network server with~\code{server_loop} as its entry point (\entrypoint).
The server runs in a loop and calls~\code{handle_request}, which handles each network request.
The function~\code{handle_request} reads data from the socket through~\code{read_msg} and based on the first byte, either~\code{process_req1} or~\code{process_req2} will be called to handle the request.

\myparagraph{The Vulnerability}
As we can see, there is an arbitrary memory write vulnerability (indicated by~\realbug) in~\code{process_req1} because of using~\code{i} as an index into the array~\code{msg} without any sanity check.
The variable~\code{i} can take any integer value as it is parsed from~\code{msg}, whose contents are read from socket in~\code{read_msg} indicated by~\rootcause.

\myparagraph{Goal} 
The developer's goal is to partition the code in~\lst{lst:comb} so that spatial memory vulnerabilities do not affect the overall program.
Ideally, the developer must convert the entire code to Checked C so that the entire program achieves spatial memory safety.
However, Checked C has restrictions that can result in a considerable conversion effort.
For instance,~\code{void*} pointers are not directly supported by Checked C.
Consequently, the developer needs to convert functions using~\code{void*} pointers into generic versions -- this could be tedious.
To handle this, the developer can do a best-effort conversion and annotate only a few pointers~\eg by using an automated conversion tool such as~\threec{} which annotates few pointers as shown in~\lst{lst:initialconv}.
However, as shown in~\sect{subsec:nosafetyagsintuncheckedcode}, the unchecked code can also affect the safety of checked pointers.
\aravind{Fix the running example code with the annotations according to the implementation.}
\subsection{\systemname Annotations}
\label{subsec:moveregionstosbx}
%\myparagraph{Using tainted types}
To handle this, the developer marks risky functions with unchecked pointers,~\ie~\code{read_msg} and~\code{process_req1} as~\code{tainted} as shown in~\lst{lst:humantaint} indicated by~\useradded.
The developer starts using~\systemname{} with the resulting partially annotated program with checked and tainted types~\ie~\lst{lst:initialconv} and~\ref{lst:humantaint} atop of~\lst{lst:comb}.
The initial tainted functions might require other pointers to be marked as tainted according to our typing rules (CITE).
The developer uses our type checker to identify the additional annotations (\usermods) required to have a well-typed program and adds them as shown in~\lst{lst:humanadjust}.
The resulting well-typed program as shown in~\lst{lst:final} will be passed to our source level program partitioner along with certain configuration parameters of the target sandbox.

\subsection{Partitioning}
Our partitioner splits the provided program into two sets of source files with the necessary source changes required to communicate with sandboxed code.
These sets of source files will be compiled with the corresponding compilers to get the corresponding object files.
The \cregion object file will have the necessary runtime checks enforcing~\systemname{} guarantees.
The~\ucregion object file will be produced according to the corresponding sandbox mechanism.
Finally, these two object files will be linked along with the necessary sandbox libraries to produce the final executable such that all the tainted functions will be executed in a sandbox (\ucregion) and the rest of the functions as regular code (\cregion).

%newusecase.tex


