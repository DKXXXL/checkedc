\section{Overview}\label{sec:overview}

Give an overview of Checked-C and RLBox.

\begin{enumerate}

\item discuss Checked-C and its usage.

\item discuss RLBox.

\item A running example (web-browser with third party libraries).

\end{enumerate}


\section{Key Updates}\label{sec:key-updates}

This section discusses the key merge features between Checked-C and RLBox and the problems we are trying to solve.

\begin{enumerate}

\item Pointing out that the current Checked-C and C formalism is not enough to ensure the security of linking web-browser with third party libraries. Pointing out that even though Checked-C previously has blame theorem, but it still allows program crashing, and our new work can guarantee that every crashes can be detected and handled (non-crashing theorem).

\item Using an example to highlight the overhead of RLBox, and points out the advantage of building RLBox mechanism in a compiler.

\item Discuss function pointer formalism and points out the potential security issues without a proper handling of function pointer set up. Mentioning what happens in RLBox and other tools. Pointing out that this is the first work formalizing function pointers.

\end{enumerate}


% \paragraph*{\textbf{NT-array Pointer Formalization}} NT-array pointers point to NT-arrays whose endings are determined by a null (\code{'\0'}). The length of a NT-array is usually not fixed. The two uses of NT-array pointers in \checkedc are branching and \code{strlen} operations. \code{if (*x) }$e_1$\code{ else }$e_2$ branches to $e_1$/$e_2$ depending one the \code{x}'s data, while \code{strlen(x)} computes the length of the NT-array pointed to by \code{x}.
% \liyi{move to formal and later section.}
  
% \paragraph*{\textbf{Dependent Functions}} \checkedc allows users to declare dependent functions.  Fig.~\ref{fig:checkedc-example} shows an example usage of dependent functions. The integer argument \code{x} is used to specify the bounds of the two NT-array pointers. It means that when we call the \code{memcpy} function, the upper-bounds of the two NT-array pointers must be no less than \code{x}. If the programmer makes the mistake of writing \lstinline{i <= x} in the for loop, the runtime checks will ensure that the indexing of\lstinline|x| in either \code{a} or \code{b} results in an error.
% Because of the dependent function features, we are able to utilize the fact that the two remaining length of the NT-array pointers are greater than \code{x}, so that the \code{for} is guaranteed to execute properly.

% \ignore{
% \liyi{Good information about pointer types here:
% https://github.com/microsoft/checkedc/wiki/New-pointer-and-array-types}




% This code creates an array pointer of length $10$, and reads the pointer $(x+y)$. 
% If the integer value $y$ is greater than $10$, executing the program in C results in undefined behavior. 
% In \checkedc, however, we links every pointer in a program with their bound information statically, and inserts checks to dynamically verify if the usage of the pointer violates the spatial safety. For example, In compiling the above fragment, we inserts the bound's check for $x$ in the read operation $(x+y)$, and if $y$ results in a value $11$, the execution of the read operation $(x+y)$ results in an dynamic error. 

% There are many existing language development trying to guarantee the C spatial safety property through different approaches. For example, Cyclone \cite{Jim2002} and Cerberus \cite{cerberus} are the fat pointer approaches for guaranteeing the spatial safety and eliminating undefined behaviors in C. Rust \cite{Rust2016}, on the other hand, tries to restrict the possible way of writing programs to guarantee such property statically.
% The problem of these two approaches are effectiveness of executing programs and user practicality of writing programs. The fat-pointer approach completely relies on dynamic checks to guarantee the safety properties but it might pay a huge price on execution efficiency. In our experiment (Sec.~\ref{sec:evaluation}), we found that the execution of fat pointer approaches cost the speed a 50\% overhead. 
% On the other hand, Rust uses a static approach by restricting the usage of pointers to guarantee the properties, which results in a user UN-friendly system.  
% The development of \checkedc is an investigation on keeping the balance between execution efficiency and user-friendly systems. We develop a system to utilize static type systems to allow the \checkedc compiler to insert dynamic checks to guarantee the safety property. The efficiency of \checkedc is in the same level of Rust while we maintain a user-friendly system and inherited most of the operation features from C.

% Another feature of \checkedc is the division of the checked and unchecked blocks. When users try to rewrite their C programs into \checkedc programs, they can develop the code incrementally by rewriting sub-parts of their programs to \checkedc code fragments and placing them as the checked blocks, while keeping the rest C programs as unchecked C programs. \checkedc guarantees that if there is any safety violation, this comes from the unchecked blocks (the blame theory). 

% Here is the contributions of the paper. First, we develop the code formalization of \checkedc and show that the type system in \checkedc is type-sound and satisfies the blame theory with respect to the \checkedc semantics. Specifically, we formalize null-terminated array pointers. To our best knowledge, this is the first work defining such feature in C-related languages. 
% Second, in formalizing the \checkedc language, we investigate the balance between program execution efficiency and user practicality. We re-investigate the \checkedc type system with subtyping relations to make it more efficient and user-friendly.
% Second, we also develop random testing tools in Redex \cite{pltredex} to test the \checkedc compiler and make sure it is properly developed. We are able to find and reproduce many bugs/faults in the \checkedc compiler \liyi{numbers?}. The random testing tool is able to generate tens of thousands of programs to properly validate the \checkedc compiler. Third, we also spent a great amount of work in developing experiments to compare \checkedc and other existing C-like languages that guarantee the spatial safety and eliminating undefined behaviors. We found that \checkedc keeps the best balance between execution efficiency and user practicality.
% }



